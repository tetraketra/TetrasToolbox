typeof(x)
type(x)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high)
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}          else
if (x < floor) {floor}      else
if (x > ceiling) {ceiling}  else x}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}           else
if (x < floor) {flagLevels[2]}          else
if (x > ceiling) {flagLevels[3]}        else flagLevels[1]}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
imputed_status <- vapply(vec, flagger, numeric(1)) #1 = too low, 2 = too high
if (sum(imputed_status >= 1, na.rm = T) == 0) {next} #Don't actually impute if there's none to be done.
data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
x <- character(1)
x
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
testing <- truncateOutliers(data)
}}}
testing <- truncateOutliers(data)
View(testing)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
testing <- truncateOutliers(data)
}}}
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
}
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
}
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}          else
if (x < floor) {floor}      else
if (x > ceiling) {ceiling}  else x}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}           else
if (x < floor) {flagLevels[2]}          else
if (x > ceiling) {flagLevels[3]}        else flagLevels[1]}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))
} else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1)
} else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
if(keepNAs) {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(NA, flagLevels[1], flagLevels[2], flagLevels[3]))
} else {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))}
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
} }
testing <- truncateOutliers(data)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
}
testing <- truncateOutliers(data)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
}
testing <- truncateOutliers(data)
is.numeric(c(0, 1, 2))
View(truncateOutliers)
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
devtools::document()
devtools::document()
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}          else
if (x < floor) {floor}      else
if (x > ceiling) {ceiling}  else x}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}           else
if (x < floor) {flagLevels[2]}          else
if (x > ceiling) {flagLevels[3]}        else flagLevels[1]}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
if(keepNAs) {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(NA, flagLevels[1], flagLevels[2], flagLevels[3]))
} else {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))}
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
testing <- truncateOutliers(data)
View(testing)
testing <- truncateOutliers(data, c(10, 14, 4))
testing <- truncateOutliers(data, c(10, 14, 4), T)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @param keepNAs If T, then "_OoB_Flag" will be NA if the original is NA. If F, then 0 instead.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2), keepNAs = F) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}          else
if (x < floor) {floor}      else
if (x > ceiling) {ceiling}  else x}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}           else
if (x < floor) {flagLevels[2]}          else
if (x > ceiling) {flagLevels[3]}        else
if (!keepNAs) {flagLevels[1]} 					else NA}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
if(keepNAs) {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(NA, flagLevels[1], flagLevels[2], flagLevels[3]))
} else {data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))}
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
testing <- truncateOutliers(data, c(10, 14, 4), T)
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA)}
else if (x < floor) {floor}
else if (x > ceiling) {ceiling}
else {x}
}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}
else if (x < floor) {flagLevels[2]}
else if (x > ceiling) {flagLevels[3]}
else {flagLevels[1]}
}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA)}
else if (x < floor) {floor}
else if (x > ceiling) {ceiling}
else {x}
}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}
else if (x < floor) {flagLevels[2]}
else if (x > ceiling) {flagLevels[3]}
else {flagLevels[1]}
}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(within, too low, too high). Can be either numeric or character.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}
else if (x < floor) {floor}
else if (x > ceiling) {ceiling}
else {x}
}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}
else if (x < floor) {flagLevels[2]}
else if (x > ceiling) {flagLevels[3]}
else {flagLevels[1]}
}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- max(c(quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR, 0))
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
testing <- truncateOutliers(data)
testing <- truncateOutliers(data, c(20, 100, -3))
testing <- truncateOutliers(data, c("unmodified", "too low", "too high"))
#' Truncate outliers in dataset to 1.5*IQR standard.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param flagLevels The values of the "_OoB_Flag"s in the format c(unmodified, too low, too high). Can be either numeric or character.
#' @return Dataframe with truncated numerical variables.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1, 2)) {
numerics_names <- names(data)[unlist(lapply(data, is.numeric))]
#This function returns a truncated value (if necessary).
cutter <- function(x) {
if (is.na(x)) {NA}
else if (x < floor) {floor}
else if (x > ceiling) {ceiling}
else {x}
}
#This function is used to build the OoB (Out of Bounds) flag variables.
flagger <- function(x) {
if (is.na(x)) {flagLevels[1]}
else if (x < floor) {flagLevels[2]}
else if (x > ceiling) {flagLevels[3]}
else {flagLevels[1]}
}
for (var in numerics_names) {
vec <- data[[var]]
IQR <- quantile(vec, 0.75, na.rm = T, names = F) - quantile(vec, 0.25, na.rm = T, names = F)
floor <- quantile(vec, 0.25, na.rm = T, names = F) - 1.5*IQR
ceiling <- quantile(vec, 0.75, na.rm = T, names = F) + 1.5*IQR
if (is.numeric(flagLevels)) {imputed_status <- vapply(vec, flagger, numeric(1))}
else if (is.character(flagLevels)) {imputed_status <- vapply(vec, flagger, character(1))}
else {stop("Flag levels must be numeric or character.")}
if (sum(imputed_status >= 1, na.rm = T) == flagLevels[1]) {next} #Don't actually impute if there's none to be done.
data[[paste(var, "_OoB_Flag", sep = "")]] <- factor(imputed_status, levels = c(flagLevels[1], flagLevels[2], flagLevels[3]))
data[[paste(var, "_Truncated", sep = "")]] <- vapply(vec, cutter, numeric(1))
}
data
}
testing <- truncateOutliers(data, c("unmodified", "too low", "too high"))
setwd("~/GitHub/TetrasToolbox/R")
rm(list = ls())
devtools::document()
setwd("C:/Users/Ben Silverberg/OneDrive - William & Mary/BDA_Ass3")
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
index <- read.csv("WINE.csv", header=T)[1]
n.obs <- nrow(data)
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox)
?truncateOutliers
?generateExploratory.numeric
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox)
?truncateOutliers
testing <- truncateOutliers(data)
View(testing)
install.packages("mice")
library(mice)
#' Impute missing variables across the *entire* dataset using MICE.
#'
#' This accepts the *entire* dataset and returns the *entire* dataset with new variables.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param meth The method to be passed to the mice() function.
#' @param flagLevels The values of the "_Imputed_Flag" variable in the format c(unmodified, was NA). Can be either numeric or character.
#' @return Dataframe with added "_Imputed_Flag" variable and changed values.
#' @export
truncateOutliers <- function(data, flagLevels = c(0, 1), miceMeth = "pmm", miceSeed = NA, miceM = 5, miceMaxit = 50) {
na_names <- names(which(colSums(is.na(data)) > 0))
for (name in na_names) { #For the variables which have NA values...
vec <- data[[name]] #Take them as raw vectors...
if (sum(is.na(vec)) == 0) {next} #Don't create an imputation flag if there weren't any values to be imputed. Otherwise...
data[[paste(name, "_Imputed_Flag", sep = "")]] <- as.numeric(is.na(vec))} #Create an imputation flag (name based on OG variables) variable.
data[na_names] <- data[na_names] |> mice(m = miceM, maxit = miceMaxit, meth = miceMeth, seed = miceSeed) |> complete() #No flag variables have been used to generate imputations.
data
}
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
setwd("C:/Users/Ben Silverberg/OneDrive - William & Mary/BDA_Ass3")
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
#' Impute missing variables across the *entire* dataset using MICE.
#'
#' This accepts the *entire* dataset and returns the *entire* dataset with new variables.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param meth The method to be passed to the mice() function.
#' @param flagLevels The values of the "_Imputed_Flag" variable in the format c(unmodified, was NA). Can be either numeric or character.
#' @return Dataframe with added "_Imputed_Flag" variable and changed values.
#' @export
imputeMissing <- function(data, flagLevels = c(0, 1), miceMeth = "pmm", miceSeed = NA, miceM = 5, miceMaxit = 50) {
na_names <- names(which(colSums(is.na(data)) > 0))
for (name in na_names) { #For the variables which have NA values...
vec <- data[[name]] #Take them as raw vectors...
if (sum(is.na(vec)) == 0) {next} #Don't create an imputation flag if there weren't any values to be imputed. Otherwise...
data[[paste(name, "_Imputed_Flag", sep = "")]] <- as.numeric(is.na(vec))} #Create an imputation flag (name based on OG variables) variable.
data[na_names] <- data[na_names] |> mice(m = miceM, maxit = miceMaxit, meth = miceMeth, seed = miceSeed) |> complete() #No flag variables have been used to generate imputations.
data
}
testing <- imputeMissing(data)
install.packages(mice)
install.packages("mice")
library(mice)
install.packages("utf8")
library(utf8)
#' Impute missing variables across the *entire* dataset using MICE.
#'
#' This accepts the *entire* dataset and returns the *entire* dataset with new variables.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param meth The method to be passed to the mice() function.
#' @param flagLevels The values of the "_Imputed_Flag" variable in the format c(unmodified, was NA). Can be either numeric or character.
#' @return Dataframe with added "_Imputed_Flag" variable and changed values.
#' @export
imputeMissing <- function(data, flagLevels = c(0, 1), miceMeth = "pmm", miceSeed = NA, miceM = 5, miceMaxit = 50) {
na_names <- names(which(colSums(is.na(data)) > 0))
numeric_names <- names(data)[unlist(lapply(data, is.numeric))]
na_numeric_names <- na_names & numeric_names
for (name in na_numeric_names) { #For the variables which have NA values...
vec <- data[[name]] #Take them as raw vectors...
if (sum(is.na(vec)) == 0) {next} #Don't create an imputation flag if there weren't any values to be imputed. Otherwise...
data[[paste(name, "_Imputed_Flag", sep = "")]] <- as.numeric(is.na(vec))} #Create an imputation flag (name based on OG variables) variable.
data[na_numeric_names] <- data[na_numeric_names] |> mice::mice(m = miceM, maxit = miceMaxit, meth = miceMeth, seed = miceSeed) |> mice::complete() #No flag variables have been used to generate imputations.
data
}
testing <- imputeMissing(data)
numeric_names <- names(data)[unlist(lapply(data, is.numeric))]
numeric_names
na_names <- names(which(colSums(is.na(data)) > 0))
na_names
intersect(na_names, numeric_names)
#' Impute missing variables across the *entire* dataset using MICE.
#'
#' This accepts the *entire* dataset and returns the *entire* dataset with new variables.
#'
#' @param data The data to extract numeric variables from and subsequently truncate.
#' @param meth The method to be passed to the mice() function.
#' @param flagLevels The values of the "_Imputed_Flag" variable in the format c(unmodified, was NA). Can be either numeric or character.
#' @return Dataframe with added "_Imputed_Flag" variable and changed values.
#' @export
imputeMissing <- function(data, flagLevels = c(0, 1), miceMeth = "pmm", miceSeed = NA, miceM = 5, miceMaxit = 50) {
na_names <- names(which(colSums(is.na(data)) > 0))
numeric_names <- names(data)[unlist(lapply(data, is.numeric))]
na_numeric_names <- intersect(na_names, numeric_names)
for (name in na_numeric_names) { #For the variables which have NA values...
vec <- data[[name]] #Take them as raw vectors...
if (sum(is.na(vec)) == 0) {next} #Don't create an imputation flag if there weren't any values to be imputed. Otherwise...
data[[paste(name, "_Imputed_Flag", sep = "")]] <- as.numeric(is.na(vec))} #Create an imputation flag (name based on OG variables) variable.
data[na_numeric_names] <- data[na_numeric_names] |> mice::mice(m = miceM, maxit = miceMaxit, meth = miceMeth, seed = miceSeed) |> mice::complete() #No flag variables have been used to generate imputations.
data
}
testing <- imputeMissing(data)
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
rm(list = ls())
devtools::document()
devtools::install_github("tetraketra/TetrasToolbox")
?TetrasToolbox::truncateOutliers
?TetrasToolbox::imputeMissing
setwd("C:/Users/Ben Silverberg/OneDrive - William & Mary/BDA_Ass3")
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
setwd("C:/Users/Ben Silverberg/OneDrive - William & Mary/BDA_Ass3")
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox)
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
index <- read.csv("WINE.csv", header=T)[1]
n.obs <- nrow(data)
testing <- TetrasToolbox::imputeMissing(data, c("wasnt", "was"))
setwd("~/GitHub/TetrasToolbox/R")
rm(list = ls())
devtools::document()
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox
)
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
setwd("C:/Users/Ben Silverberg/OneDrive - William & Mary/BDA_Ass3")
#Importing
data <- read.csv("WINE.csv", header=T)[-1]
testing <- imputeMissing(data, c("wasn't", "was"))
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox)
setwd("~/GitHub/TetrasToolbox/R")
devtools::document()
devtools::install_github("tetraketra/TetrasToolbox")
library(TetrasToolbox)
x <- rnorm(20, 20, 13)
summaryFunctions(x)
summaryFunctions(x, c("mean", "median", "max", "IQR"))
